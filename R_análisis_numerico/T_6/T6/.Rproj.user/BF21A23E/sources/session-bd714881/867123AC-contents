---
title: " Murillo Alba Josué Iván Ecuaciones Diferenciales Ordinarias"
author: " Tarea 6 Análisis Numérico"
date: "Abril 2024"
output: 
  html_document:
    toc: true
    toc_depth: 1
    theme: cerulean
---





<style>
body {
text-align: justify}
</style>



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(tidyverse)
library(pracma)
library(plotly)
library(polynom)
```

# Problema 1 {.tabset} 
  Newton's Law of Cooling states that the rate of cooling of an object is proportional to the temperature difference between the object and its surroundings. Suppose t
 is time, T
 is the temperature of the object, and Ts
 is the surrounding temperature. The following differential equation describes Newton's Law
dTdt=k(T−Ts),
where k
 is a constant.

Suppose that we consider a 90∘C
 cup of coffee in a 24∘C
 room. Suppose it is known that the coffee cools at a rate of 2∘C/min.
 when it is 70∘C.
 Answer the following questions.
 

##  Find the constant k
 
```{r}
T0 <- 70  
Ts <- 24  
dT_dt <- -2  

k <- dT_dt / (T0 - Ts)
cat("k es:", k, "1/min\n")

```
 
## What is the limiting value of the temperature?

Para encontrar el valor límite de T, establecemos el lado izquierdo de la ecuación en cero (ya que la tasa de cambio se acerca a cero en el equilibrio):

0=k(T0-Ts)
T=Ts=24°C
Por lo tanto, el valor límite de la temperatura es de 24°C. En el equilibrio, la taza de café eventualmente se enfriará a la temperatura ambiente.

## Use Euler's method with step size h=2, T(10)

```{r}
f <- function(T0, Ts, k, h, t) {
  T <- T0
  for (i in 1:(t/h)) {
    T <- T + h * k * (T - Ts)
  }
  return(T)
}

T0 <- 90  
Ts <- 24  
h <- 2    
t <- 10   # Tiempo total en minutos
k <- -0.04347826


T10 <- f(T0, Ts, k, h, t)

print(paste("T(10) ≈", T10, "°C"))
```

# Problema 2 {.tabset}
Use Euler's method with the given step size to estimate y(1.4)
 where y(x)
 is the solution of the initial-value problem
y′=x−xy,y(1)=0.

## . Estimate y(1.4) h=0.2

```{r}
dy <- function(x,y){
  x-x*y
}
y_sol <- function(x){
  1-exp(1/2-x^2/2)
}

my_euler <- function(dy, a,b, N, y0){
  h <- 0.2
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 1.4, 100, 0)

indice <- which(sol_aprox$T == 1.4)
print(sol_aprox$W[indice])


my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  coord_cartesian(xlim = c(1, 1.4))+
  theme_bw()

ggplotly(graf)


```

## . Estimate y(1.4) h=0.1


```{r}
dy <- function(x,y){
  x-x*y
}
y_sol <- function(x){
  1-exp(1/2-x^2/2)
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 1.4, 4, 0)

indice <- which.min(abs(sol_aprox$T - 1.4))
print(paste("El valor de W en T = 1.4 es:", sol_aprox$W[indice]))

my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  coord_cartesian(xlim = c(1, 1.4))+
  theme_bw()

ggplotly(graf)

```

# Problema 3 {.tabset}

Suppose that we use the Improved Euler's method to approximate the solution to the differential equation 
$ \frac{dy}{dx}=x−2y; \quad y(0.1)=1$.
Let 
$f(x,y)=x−2y.$

We let $x0=0.1$
 and $y0=1$
 and pick a step size h=0.25.
 The improved Euler method is the the following algorithm. From (xn,yn),
 our approximation to the solution of the differential equation at the n
-th stage, we find the next stage by computing the x
-step $xn+1=xn+h$,
 and then $k1$,
 the slope at $(x_n,y_n).$
 The predicted new value of the solution is zn+1=yn+h⋅k1.
 Then we find the slope at the predicted new point k2=f(xn+1,zn+1)
 and get the corrected point by averaging slopes
yn+1=yn+h2(k1+k2).

```{r}
f <- function(x, y) {
  x - 2 * y
}

y_sol <- function(x) {
  x / 2 + (6 * exp(1 / 5 - 2 * x) / 5) - 1 / 4
}

euler_modificado <- function(f, a, b, N, y0) {
  h <- (b - a) / N
  X <- seq(a, b, by = h)
  Y <- y0
  K1<-numeric()
  K2<-numeric()
  Z<-numeric()
  for (k in 1:N) {
    K1[k]<- f(X[k], Y[k])
    Z[k]=Y[k]+h*K1[k]
    K2[k]=f(X[k+1], Z[k])
    Y[k + 1] <- Y[k] + h / 2 *(K1[k]+ K2[k])
   # Y[k + 1] <- Y[k] + h / 2 * (f(X[k], Y[k])+f(X[k + 1], Y[k] + h * f(X[k], Y[k])))
    

  }
  resultados <- list("X" = X, "Y" = Y, "K1"=K1, "Z"=Z, "K2"=K2)
  return(resultados)
}

sol_aprox<-euler_modificado(f,0.1, 1.1,4,1)


graf <- ggplot() +
  geom_function(fun = y_sol, xlim = c(0.1, 1.1), color = "red4", linewidth = .7) +
  geom_line(aes(x = sol_aprox$X, y = sol_aprox$Y), color = "cyan3", linewidth = .7) +
  theme_test()

ggplotly(graf)



```








