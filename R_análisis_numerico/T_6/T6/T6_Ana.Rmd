---
title: " Murillo Alba Josué Iván Ecuaciones Diferenciales Ordinarias"
author: " Tarea 6 Análisis Numérico"
date: "Abril 2024"
output: 
  html_document:
    toc: true
    toc_depth: 1
    theme: cerulean
---





<style>
body {
text-align: justify}
</style>



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(tidyverse)
library(pracma)
library(plotly)
library(polynom)
```

# Problema 1 {.tabset} 
  Newton's Law of Cooling states that the rate of cooling of an object is proportional to the temperature difference between the object and its surroundings. Suppose t
 is time, T
 is the temperature of the object, and Ts
 is the surrounding temperature. The following differential equation describes Newton's Law
dTdt=k(T−Ts),
where k
 is a constant.

Suppose that we consider a 90∘C
 cup of coffee in a 24∘C
 room. Suppose it is known that the coffee cools at a rate of 2∘C/min.
 when it is 70∘C.
 Answer the following questions.
 

##  Find the constant k
 
```{r}
T0 <- 70  
Ts <- 24  
dT_dt <- -2  

k <- dT_dt / (T0 - Ts)
cat("k es:", k, "1/min\n")

```
 
## What is the limiting value of the temperature?

Para encontrar el valor límite de T, establecemos el lado izquierdo de la ecuación en cero (ya que la tasa de cambio se acerca a cero en el equilibrio):

0=k(T0-Ts)
T=Ts=24°C
Por lo tanto, el valor límite de la temperatura es de 24°C. En el equilibrio, la taza de café eventualmente se enfriará a la temperatura ambiente.

## Use Euler's method with step size h=2, T(10)

```{r}
f <- function(T0, Ts, k, h, t) {
  T <- T0
  for (i in 1:(t/h)) {
    T <- T + h * k * (T - Ts)
  }
  return(T)
}

T0 <- 90  
Ts <- 24  
h <- 2    
t <- 10   # Tiempo total en minutos
k <- -0.04347826


T10 <- f(T0, Ts, k, h, t)

print(paste("T(10) ≈", T10, "°C"))
```

# Problema 2 {.tabset}
Use Euler's method with the given step size to estimate y(1.4)
 where y(x)
 is the solution of the initial-value problem
y′=x−xy,y(1)=0.

## . Estimate y(1.4) h=0.2

```{r}
dy <- function(x,y){
  x-x*y
}
y_sol <- function(x){
  1-exp(1/2-x^2/2)
}

my_euler <- function(dy, a,b, N, y0){
  h <- 0.2
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 1.4, 100, 0)

indice <- which(sol_aprox$T == 1.4)
print(sol_aprox$W[indice])

my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  coord_cartesian(xlim = c(1, 1.4))+
  theme_bw()

ggplotly(graf)

```


## . Estimate y(1.4) h=0.1


```{r}
dy <- function(x,y){
  x-x*y
}
y_sol <- function(x){
  1-exp(1/2-x^2/2)
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 1.4, 4, 0)

indice <- which.min(abs(sol_aprox$T - 1.4))
print(paste("El valor de W en T = 1.4 es:", sol_aprox$W[indice]))

my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  coord_cartesian(xlim = c(1, 1.4))+
  theme_bw()

ggplotly(graf)

```

## Comparaciones


```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 x - x * y
}

# Solución exacta
y_sol <- function(x){
  1 - exp(1/2 - x^2/2)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)



```




# Problema 3 

Suppose that we use the Improved Euler's method to approximate the solution to the differential equation 
$ \frac{dy}{dx}=x−2y; \quad y(0.1)=1$.
Let 
$f(x,y)=x−2y.$

We let $x0=0.1$
 and $y0=1$
 and pick a step size h=0.25.
 The improved Euler method is the the following algorithm. From (xn,yn),
 our approximation to the solution of the differential equation at the n
-th stage, we find the next stage by computing the x
-step $xn+1=xn+h$,
 and then $k1$,
 the slope at $(x_n,y_n).$
 The predicted new value of the solution is zn+1=yn+h⋅k1.
 Then we find the slope at the predicted new point k2=f(xn+1,zn+1)
 and get the corrected point by averaging slopes
yn+1=yn+h2(k1+k2).

```{r}
f <- function(x, y) {
  x - 2 * y
}

y_sol <- function(x) {
  x / 2 + (6 * exp(1 / 5 - 2 * x) / 5) - 1 / 4
}

euler_modificado <- function(f, a, b, N, y0) {
  h <- (b - a) / N
  X <- seq(a, b, by = h)
  Y <- y0
  K1<-numeric()
  K2<-numeric()
  Z<-numeric()
  for (k in 1:N) {
    K1[k]<- f(X[k], Y[k])
    Z[k]=Y[k]+h*K1[k]
    K2[k]=f(X[k+1], Z[k])
    Y[k + 1] <- Y[k] + h / 2 *(K1[k]+ K2[k])
   # Y[k + 1] <- Y[k] + h / 2 * (f(X[k], Y[k])+f(X[k + 1], Y[k] + h * f(X[k], Y[k])))
    

  }
  resultados <- list("X" = X, "Y" = Y, "K1"=K1, "Z"=Z, "K2"=K2)
  return(resultados)
}

sol_aprox<-euler_modificado(f,0.1, 1.1,4,1)


graf <- ggplot() +
  geom_function(fun = y_sol, xlim = c(0.1, 1.1), color = "red4", linewidth = .7) +
  geom_line(aes(x = sol_aprox$X, y = sol_aprox$Y), color = "cyan3", linewidth = .7) +
  theme_test()

ggplotly(graf)



```

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 x - 2 * y
}

# Solución exacta
y_sol <- function(x){
  x / 2 + (6 * exp(1 / 5 - 2 * x) / 5) - 1 / 4
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```




# Problema 4 
Suppose that we use Euler's method to approximate the solution to the differential equation
$ \frac{dy}{dx}=x^2/y; \quad y(0.1)=8$

Let $f(x,y)=x^2/y.$

We let $x0=0.1$
 and $y0=8$
 and pick a step size $h=0.2.$
 Euler's method is the the following algorithm. From xn
 and yn,
 our approximations to the solution of the differential equation at the nth stage, we find the next stage by computing
xn+1=xn+h,yn+1=yn+h⋅f(xn,yn).

```{r}
f <- function(x, y) {
  x^2/y
}

euler_modificado <- function(f, a, b, N, y0) {
  h <- (b - a) / N
  X <- seq(a, b, by = h)
  Y <- numeric(N + 1)
  Y[1] <- y0
  for (k in 1:N) {
    Y[k + 1] <- Y[k] + h * f(X[k], Y[k])
  }
  resultados <- list("X" = X, "Y" = Y)
  return(resultados)
}

sol_aprox <- euler_modificado(f, 0.1, 1.1, 5, 8)


graf <- ggplot() +
  geom_function(fun = y_sol, xlim = c(0.1, 1.1), color = "red4", linewidth = .7) +
  geom_line(aes(x = sol_aprox$X, y = sol_aprox$Y), color = "cyan3", linewidth = .7) +
  theme_test()

ggplotly(graf)
```

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 x^2/y
}

# Solución exacta
y_sol <- function(x){
  ((15000*x^3+1439985)^(1/2))/150
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```



# Problema 5{.tabset}

Let y(t)
 be the solution to y˙=3te−y
 satisfying y(0)=−2
.

## (a) Use Euler's Method with time step h=0.2to approximate y(0.2),y(0.4),...,y(1.0)
.

```{r}
dy <- function(t,y){
  3*t*exp(-y)
}
y_sol <- function(t){
  log(3*t^2/2+exp(-2))
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 1, 5, -2)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=y_sol, xlim=c(0,1))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)

```

## errores

```{r}
# Calcular los errores en las aproximaciones
error_0.2 <- abs(y_sol(0.2) - sol_aprox$W[which(sol_aprox$T == 0.2)])
error_0.6 <- abs(y_sol(0.6) - sol_aprox$W[which(sol_aprox$T == 0.6)])
error_0.6 <- numeric(0)
indice_0.6 <- which.min(abs(sol_aprox$T - 0.6))
if (length(indice_0.6) > 0) {
  error_0.6 <- abs(y_sol(0.6) - sol_aprox$W[indice_0.6])
}

error_1 <- abs(y_sol(1) - sol_aprox$W[which(sol_aprox$T == 1)])



```

## Comparaciones
```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 3*x*exp(-y)
}

# Solución exacta
y_sol <- function(x){
  log(3*x^2/2+exp(-2))
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```




# Problema 6

 Fill in the missing values in the table given if you know that dy/dt=0.2y
. Assume the rate of growth given by dy/dt
 is approximately constant over each unit time interval and that the initial value of y
 is 5


```{r}
dy <- function(t,y){
  0.2*y
}
y_sol <- function(t){
  5*exp(t/5)
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 4, 4, 5)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=y_sol, xlim=c(0,4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)

```


```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
  0.2*y
}

# Solución exacta
y_sol <- function(x){
  5*exp(x/5)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```



# Problema 7 {.tabset}
$ \frac{dB}{dt}=0.06B; \quad B(0)=1500$

## A. Δt=1 and 1 step:  B(1)≈

```{r}
dB <- function(t, B) {
  0.06 * B
}

B_sol <- function(t) {
  1500 * exp(0.06 * t)
}

my_euler <- function(dB, a, b, N, y0) {
  h <- (b - a) / N
  T <- seq(a, b, by = h)
  W <- numeric(N + 1)
  W[1] <- y0
  for (k in 1:N) {
    W[k + 1] <- W[k] + h * dB(T[k], W[k])
  }
  resultados <- list("T" = T, "W" = W)
  return(resultados)
}

a <- 0     
b <- 1     
N <- 1     
y0 <- 1500 


sol_aprox <- my_euler(dB, a, b, N, y0)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=B_sol, xlim=c(0,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```

## B. Δt=0.5 and 2 steps: B(1)≈
 
```{r}
dB <- function(t, B) {
  0.06 * B
}

B_sol <- function(t) {
  1500 * exp(0.06 * t)
}

my_euler <- function(dB, a, b, N, y0) {
  h <- (b - a) / N
  T <- seq(a, b, by = h)
  W <- numeric(N + 1)
  W[1] <- y0
  for (k in 1:N) {
    W[k + 1] <- W[k] + h * dB(T[k], W[k])
  }
  resultados <- list("T" = T, "W" = W)
  return(resultados)
}

a <- 0     
b <- 1     
N <- 2  
y0 <- 1500 


sol_aprox <- my_euler(dB, a, b, N, y0)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=B_sol, xlim=c(0,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```

## C. Δt=0.25 and 4 steps: B(1)≈
 

```{r}
dB <- function(t, B) {
  0.06 * B
}

B_sol <- function(t) {
  1500 * exp(0.06 * t)
}

my_euler <- function(dB, a, b, N, y0) {
  h <- (b - a) / N
  T <- seq(a, b, by = h)
  W <- numeric(N + 1)
  W[1] <- y0
  for (k in 1:N) {
    W[k + 1] <- W[k] + h * dB(T[k], W[k])
  }
  resultados <- list("T" = T, "W" = W)
  return(resultados)
}

a <- 0     
b <- 1     
N <- 4   
y0 <- 1500 


sol_aprox <- my_euler(dB, a, b, N, y0)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=B_sol, xlim=c(0,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```


## D. Suppose B
 is the balance in a bank account earning interest. Be sure that you can explain why the result of your calculation in part (a) is equivalent to compounding the interest once a year instead of continuously. Then interpret the result of your calculations in parts (b) and (c) in terms of compound interest.
 
 Capitalización anual vs. Continua: En el método de Euler, estamos aproximando la función 
B(t) que representa el saldo en la cuenta bancaria en intervalos discretos de tiempo. En la parte (a), cuando 
Δt=1, estamos calculando el saldo de la cuenta después de un año, utilizando el interés simple, donde el interés se calcula una vez al año. Esto es equivalente a capitalizar el interés una vez al año. Sin embargo, cuando 
Δt es más pequeño, como en las partes (b) y (c), estamos dividiendo el año en intervalos más pequeños y calculando el saldo de la cuenta más frecuentemente, lo que se asemeja más al interés compuesto, donde el interés se calcula y se agrega al saldo de la cuenta en intervalos infinitesimales de tiempo.
En términos de interés compuesto: En interés compuesto, el interés se calcula y se agrega al saldo de la cuenta en intervalos cortos de tiempo. Cuando utilizamos Δt=0.5 y 2 pasos en la parte (b), y
Δt=0.2 y 4 pasos en la parte (c), estamos calculando el saldo de la cuenta en intervalos más cortos de tiempo y más frecuentemente. Esto resulta en un saldo final más alto en comparación con el interés simple, ya que el interés se está capitalizando más frecuentemente, lo que genera un crecimiento exponencial del saldo de la cuenta.


# Problema 8 {.tabset}

 Consider the solution of the differential equation y′=−y
 passing through y(0)=1
.
## A.
Sketch the slope field for this differential equation, and sketch the solution passing through the point (0,1).
```{r}
# Cargar la librería
library(ggplot2)

# Definir la ecuación diferencial
dy <- function(t, y) {
  -y
}

# Método de Euler para aproximar la solución
euler <- function(dy, t_range, y0, h) {
  t <- seq(t_range[1], t_range[2], by = h)
  y <- numeric(length(t))
  y[1] <- y0
  for (i in 2:length(t)) {
    y[i] <- y[i - 1] + h * dy(t[i - 1], y[i - 1])
  }
  return(data.frame(t = t, y = y))
}

# Parámetros
t_range <- c(0, 1)  # Rango de tiempo
y0 <- 1             # Condición inicial
h <- 0.1            # Tamaño de paso

# Aproximar la solución utilizando el método de Euler
sol <- euler(dy, t_range, y0, h)

# Graficar el campo de pendiente
ggplot(data.frame(t = seq(t_range[1], t_range[2], by = 0.5)), aes(t, 1)) +
  geom_segment(aes(yend = 1 + 0.5 * dy(t, 1), xend = t), arrow = arrow(length = unit(0.3, "cm"))) +
  geom_point(data = data.frame(t = 0, y = 1), aes(t, y), color = "red", size = 3) +
  geom_path(data = sol, aes(t, y), color = "blue") +
  xlim(t_range) +
  ylim(c(-1, 2)) +
  labs(x = "t", y = "y(t)", title = "Campo de pendiente y Solución") +
  theme_minimal()

```

## B
Use Euler's method with step size Δx=0.2
 to estimate the solution at x=0.2,0.4,…,1
, using these to fill in the following table. (Be sure not to round your answers at each step!)

```{r}
f <- function(x, y) {
  -y
}

euler_modificado <- function(f, a, b, N, y0) {
  h <- (b - a) / N
  X <- seq(a, b, by = h)
  Y <- numeric(N + 1)
  Y[1] <- y0
  for (k in 1:N) {
    Y[k + 1] <- Y[k] + h * f(X[k], Y[k])
  }
  resultados <- list("X" = X, "Y" = Y)
  return(resultados)
}

sol_aprox <- euler_modificado(f, 0, 1, 5, 1)


graf <- ggplot() +
  geom_function(fun = y_sol, xlim = c(0, 1), color = "red4", linewidth = .7) +
  geom_line(aes(x = sol_aprox$X, y = sol_aprox$Y), color = "cyan3", linewidth = .7) +
  theme_test()

ggplotly(graf)
```

```{r}
dy <- function(x,y){
  -y
}
y_sol <- function(x){
  1/exp(x)
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 1, 5, 1)

my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(0,1))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```

## C
Plot your estimated solution on your slope field. Compare the solution and the slope field. Is the estimated solution an over or under estimate for the actual solution?

subestimados

## Comparación

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 -y
}

# Solución exacta
y_sol <- function(x){
   1/exp(x)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)


```



# Problema 9 {.tabset}

Consider the differential equation
$ \frac{dy}{dx}=4x; \quad y(0)=4$.

## A 
Use Euler's method with two steps to estimate y
 when x=1

```{r}
dy <- function(x,y){
  4*x
}
y_sol <- function(x){
  2*x^2+4
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 1, 2, 4)
Y_aprox_1 <- sol_aprox$W[length(sol_aprox$W)]

# Calcular B_sol(1) (solución exacta)
Y_exact <- y_sol(1)


my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(0,1))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```


## B
Now use four steps:

```{r}
dy <- function(x,y){
  4*x
}
y_sol <- function(x){
  2*x^2+4
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 1, 4, 4)
Y_aprox_1 <- sol_aprox$W[length(sol_aprox$W)]

# Calcular B_sol(1) (solución exacta)
Y_exact <- y_sol(1)


my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(0,1))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```


## C
C. What is the magnitude of the error in the two Euler approximations you found?
Magnitude of error in Euler with 2 steps = 

Magnitude of error in Euler with 4 steps =

## D

By what factor should the error in these approximations change (that is, the error with two steps should be what number times the error with four)?

El factor por el cual cambia el error en estas aproximaciones se puede calcular dividiendo el error con dos pasos entre el error con cuatro pasos
factor=(Error euler N=2)/(Error euler N=4)

## Comparación

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
  4*x
}

# Solución exacta
y_sol <- function(x){
  2*x^2+4
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)



```



# Problema 10 {.tabset}

$y'= -x-y$

## Use Euler's method with Δx=0.1
 to estimate y
 when x=1.4
 for the solution curve satisfying
y(1)=1
 : Euler's approximation gives y(1.4)≈
 
```{r}
dy <- function(x,y){
  -x-y
}
y_sol <- function(x){
  exp(1-x)-x+1
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 1.4, 4, 1)

my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```
 

## Use Euler's method with Δx=0.1
 to estimate y
 when x=2.4
 for the solution curve satisfying y(1)=0
 : Euler's approximation gives  y(2.4)≈

```{r}
dy <- function(x,y){
  -x-y
}
y_sol <- function(x){
  exp(1-x)-x+1
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 2.4, 14, 0)

my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,2.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```

## Comparación

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 -x-y
}

# Solución exacta
y_sol <- function(x){
  exp(1-x)-x+1
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)


```






# Problema 11
Use Euler's method with step size 0.25
 to compute the approximate y -values y1,
 y2, y3, and y4 of the solution of the initial-value problem

$y′=−2+5x+2y$   $y(0)=1.$

$-(10*x+5*exp(2*x)+1)/4$


```{r}
f <- function(x, y) {
  return(-2 + 5*x + 2*y)
}

h <- 0.25
x0 <- 0
y0 <- 1

euler <- function(x, y, h) {
  return(y + h * f(x, y))
}

x1 <- x0 + h
y1 <- euler(x0, y0, h)

x2 <- x1 + h
y2 <- euler(x1, y1, h)

x3 <- x2 + h
y3 <- euler(x2, y2, h)

x4 <- x3 + h
y4 <- euler(x3, y3, h)

print(paste("y1 ≈", y1))
print(paste("y2 ≈", y2))
print(paste("y3 ≈", y3))
print(paste("y4 ≈", y4))
```

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 return(-2 + 5*x + 2*y)
}

# Solución exacta
y_sol <- function(x){
  -(10*x+5*exp(2*x)+1)/4
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```




# Problema 12
Use Euler's method with step size 0.3
 to estimate y(1.5)
, where y(x)
 is the solution of the initial-value problem
 
$y′=2x+y^2$   $y(0)=0$ 


```{r}
f <- function(x, y) {
  return(2*x + y^2)
}

h <- 0.3
x_target <- 1.5
x0 <- 0
y0 <- 0

euler <- function(x, y, h) {
  return(y + h * f(x, y))
}

while (x0 < x_target) {
  y0 <- euler(x0, y0, h)
  x0 <- x0 + h
}

```

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
  return(2*x + y^2)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)

```





# Problema 13

Suppose you have just poured a cup of freshly brewed coffee with temperature $90°C$ in a room where the temperature is $25°C$ Newton's Law of Cooling states that the rate of cooling of an object is proportional to the temperature difference between the object and its surroundings. Therefore, the temperature of the coffee, $T(t)$
, satisfies the differential equation
$ \frac{dT}{dt}=k(T-Troom); \quad y(0.1)=1$.
where $Troom=25$
 is the room temperature, and k
 is some constant.
Suppose it is known that the coffee cools at a rate of 1∘C
 per minute when its temperature is 75∘C
.
```{r}
T0 <- 75  
Ts <- 25  
dT_dt <- -1  

k <- dT_dt / (T0 - Ts)
cat("k es:", k, "1/min\n")
```


```{r}
f <- function(T0, Ts, k, h, t) {
  T <- T0
  for (i in 1:(t/h)) {
    T <- T + h * k * (T - Ts)
  }
  return(T)
}

T0 <- 90  
Ts <- 25  
h <- 2    
t <- 10   # Tiempo total en minutos
k <- -0.02


T10 <- f(T0, Ts, k, h, t)

print(paste("T(10) ≈", T10, "°C"))
```


```{r}
T_room <- 25  
T_initial <- 90  
k <- -0.02  

T_coffee <- 75  
rate_of_cooling <- k * (T_coffee - T_room)
print(paste("Tasa de enfriamiento cuando la temperatura del café es de 75°C:", rate_of_cooling, "°C/min"))

# Calcular el valor límite de la tasa de enfriamiento
# Cuando t tiende a infinito, la temperatura del café se acerca a la temperatura ambiente
# Entonces, la diferencia de temperatura se acerca a cero, lo que hace que la tasa de enfriamiento se acerque a cero
limiting_rate_of_cooling <- k * (T_room - T_room)
print(paste("Valor límite de la tasa de enfriamiento:", limiting_rate_of_cooling, "°C/min"))
```



# Problema 14

Solve the initial-value problem $y′+7y=4$, $y(0)=0.$

```{r}
library(ggplot2)

# Definición de la función exacta
y_sol <- function(t){
  return(4/7 - (4 * exp(-7 * t)) / 7)
}

# Definición de la ecuación diferencial
f <- function(t, y){
  return(-7 * y + 4)
}

# Definición de la función para resolver la EDO usando el método de Euler-Heun
euler_heun <- function(f, t0, tf, y0, n) {
  h <- (tf - t0) / n
  t <- seq(t0, tf, by = h)
  y <- numeric(n + 1)
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(t[i], y[i])
    k2 <- f(t[i] + h, y[i] + h * k1)
    y[i + 1] <- y[i] + (h / 2) * (k1 + k2)
  }
  return(data.frame(t = t, y = y))
}

# Obtener la aproximación numérica
sol_aprox <- euler_heun(f, 0, 2, 0, n = 10)

# Crear el gráfico
ggplot() +
  geom_function(aes(color = "y(x)"), fun = y_sol, xlim = c(0, 2)) +
  geom_line(data = sol_aprox, aes(t, y, color = "w(x)")) +
  labs(x = "t", y = "y(t)", color = "") +
  scale_color_manual(values = c("firebrick", "dodgerblue")) +
  theme_bw()

```

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 -7 * y + 4
}

# Solución exacta
y_sol <- function(x){
  4/7 - (4 * exp(-7 * x)) / 7
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```









# problema 15 {.tabset}

There is considerable evidence to support the theory that for some species there is a minimum population m
 such that the species will become extinct if the size of the population falls below m.
 This condition can be incorporated into the logistic equation by introducing the factor $(1−m/P).$
 Thus the modified logistic model is given by the differential equation
$ \frac{dP}{dt}=(1−PK)(1−mP); \quad y(0.1)=1$
where k
 is a constant and K
 is the carrying capacity.

Suppose that the carrying capacity $K=10000$,
 the minimum population $m=700$,
 and the constant $k=0.15$.
 Answer the following questions
 
```{r}
# Método de Euler-Heun
euler_heun <- function(f, t0, tf, y0, n) {
  h <- (tf - t0) / n
  t <- seq(t0, tf, by = h)
  y <- numeric(n + 1)
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(t[i], y[i])
    k2 <- f(t[i] + h, y[i] + h * k1)
    y[i + 1] <- y[i] + (h / 2) * (k1 + k2)
  }
  return(data.frame(t = t, y = y))
}


# Definición de la ecuación diferencial
f <- function(t, y) {
  return(0.15 * y * (1 - y / 10000) * (1 - 700 / y))
}

# Valor inicial
y0 <- 1000

# Obtener la aproximación numérica utilizando el método de Euler-Heun
sol_aprox <- euler_heun(f, 0, 60, y0, n = 300)

# Gráfico
library(ggplot2)
ggplot() +
  geom_line(data = sol_aprox, aes(t, y), color = "cyan") +
  labs(x = "t", y = "y(t)") +
  theme_bw()



```
 
 
#3 Suponiendo P≥0
 ¿Para qué valores de P
 ¿Está aumentando la población?
Respuesta (en notación de intervalos): 
 


##  Asumiendo P≥0
 ¿Para qué valores de P
 es la disminución de la población.
Respuesta (en notación de intervalos)
 
 
 
# Problema 16

Assuming $P≥0$,
 suppose that a population develops according to the logistic equation
$dP/dt=0.07P−0.00014P^2$
where t
 is measured in weeks. Answer the following questions.

```{r}
f<-function(t,y){
  0.07*y-0.00014*y^2
}
y0<-1


sol_aprox<-euler_heun(f,0,200,y0,n=300)
graf<-ggplot()+
  geom_line(aes(sol_aprox$t, sol_aprox$y), color="cyan")
theme_bw()

ggplotly(graf)


```


```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
  return(0.07*y-0.00014*y^2)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)

```









# Problema 17
Solve the following differential equation. $dy/dx=e^2x−3y$
 and $y=1$
 when $x=0$

```{r}
dy <- function(x,y){
  exp(2*x)-3*y
}
y_sol <- function(x){
      4/5*exp(-3*x)+exp(2*x)/5
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 2, 100, 1)

indice <- which(sol_aprox$T == 1.4)
print(sol_aprox$W[indice])


my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(0,2))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```


```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 exp(2*x)-3*y
}

# Solución exacta
y_sol <- function(x){
  4/5*exp(-3*x)+exp(2*x)/5
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```





# Problema 18
Solve the initial value problem $y′+1/(x+1)*y$ ,$y(1)=2$

```{r}
dy <- function(x,y){
  x^(-2)-1/(x+1)*y
}

y_sol <- function(x){
  (log(x)+5)/(x+1) - 1/(x*(x+1))
}

my_euler <- function(dy, a, b, N, y0){
  h <- (b-a)/N
  T <- numeric(N+1)
  W <- numeric(N+1)
  T[1] <- a
  W[1] <- y0
  for (k in 1:N) {
    W[k+1] <- W[k] + h*dy(T[k], W[k])
    T[k+1] <- T[k] + h
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 2, 100, 2)

indice <- which(sol_aprox$T == 1.4)
print(sol_aprox$W[indice])

library(ggplot2)
library(plotly)

my_colors <- c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf <- ggplot() +
  geom_function(aes(color="y(x)"), fun=y_sol, xlim=c(1,2)) +
  geom_line(aes(sol_aprox$T, sol_aprox$W, color="w(x)")) +
  scale_color_manual(values=my_colors) +
  labs(x="t", y="y(t)", color=" ") +
  theme_bw()

ggplotly(graf)

```


```{r}
dy <- function(x, y){
 x^(-2)-1/(x+1)*y
}

# Solución exacta
y_sol <- function(x){
  (log(x)+5)/(x+1) - 1/(x*(x+1))
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```








# Problema 19

$ \frac{dy}{dt}=e^t+8e^3t+y; \quad y(0)=5$

```{r}
dy <- function(t,y){
  exp(t)+8*exp(3*t)+y
}
y_sol <- function(t){
  (t+4*exp(2*t)+1)*exp(t)
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 15, 100, 5)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=y_sol, xlim=c(0,15))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```


```{r}
dy <- function(x, y){
 exp(x)+8*exp(3*x)+y
}

# Solución exacta
y_sol <- function(x){
  (x+4*exp(2*x)+1)*exp(x)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```



# Problema 20

Consider a series circuit consisting of a resistor of R
 ohms, an inductor of L
 henries, and variable voltage source of V(t)
 volts (time t
 in seconds). The current through the circuit I(t)
 (in amperes) satisfies the differential equation:
 $ \frac{dI}{dt}+ \frac{R}{L}I= \frac{1}{L}; 
 
Find the solution to this equation with the initial condition $I(0)=0$
, assuming that $R=100Ω$
, $L=5$
 H, and $V(t)$
 is constant with $V(t)=10$
 
```{r}
dy <- function(t,y){
  -20*y+2
}
y_sol <- function(t){
  1/10-exp(-20*t)/10
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 15, 100, 0)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=y_sol, xlim=c(0,15))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```
 
 
```{r}
dy <- function(x, y){
 -20*y+2
}

# Solución exacta
y_sol <- function(x){
  1/10-exp(-20*x)/10
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```
 
 
 
 
-----------------------------------------------
OLIVER

# PROBLEMA 1 {.tabset}
 
 Newton's Law of Cooling states that the rate of cooling of an object is proportional to the temperature difference between the object and its surroundings. Suppose t
 is time, T
 is the temperature of the object, and Ts
 is the surrounding temperature. The following differential equation describes Newton's Law
dTdt=k(T−Ts),
where k
 is a constant.

Suppose that we consider a 96∘C
 cup of coffee in a 16∘C
 room. Suppose it is known that the coffee cools at a rate of 1∘C/min.
 when it is 70∘C.
 Answer the following questions.
 
##  Find the constant k
 
```{r}
T0 <- 70  
Ts <- 16  
dT_dt <- -1  

k <- dT_dt / (T0 - Ts)
cat("k es:", k, "1/min\n")

```
 
## What is the limiting value of the temperature?

Para encontrar el valor límite de T, establecemos el lado izquierdo de la ecuación en cero (ya que la tasa de cambio se acerca a cero en el equilibrio):

0=k(T0-Ts)
T=Ts=16°C
Por lo tanto, el valor límite de la temperatura es de 16°C. En el equilibrio, la taza de café eventualmente se enfriará a la temperatura ambiente.

## Use Euler's method with step size h=2, T(10)

```{r}
f <- function(T0, Ts, k, h, t) {
  T <- T0
  for (i in 1:(t/h)) {
    T <- T + h * k * (T - Ts)
  }
  return(T)
}

T0 <- 96  
Ts <- 16  
h <- 2    
t <- 10   # Tiempo total en minutos
k <- -0.01851852


T10 <- f(T0, Ts, k, h, t)

print(paste("T(10) ≈", T10, "°C"))
```
 
 
# PROBLEMA 2 {.tabset}

Use Euler's method with the given step size to estimate y(1.4)
 where y(x)
 is the solution of the initial-value problem
y′=x−xy,y(1)=3.
 
## . Estimate y(1.4) h=0.2

```{r}
dy <- function(x,y){
  x-x*y
}
y_sol <- function(x){
  2*exp(1/2-x^2/2)+1
}

my_euler <- function(dy, a,b, N, y0){
  h <- 0.2
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 1.4, 100, 3)

indice <- which(sol_aprox$T == 1.4)
print(sol_aprox$W[indice])

my_colors=c("y(x)"="green", "w(x)"="pink")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  coord_cartesian(xlim = c(1, 1.4))+
  theme_bw()

ggplotly(graf)

```
 
## . Estimate y(1.4) h=0.1


```{r}
dy <- function(x,y){
  x-x*y
}
y_sol <- function(x){
 2*exp(1/2-x^2/2)+1
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 1.4, 4, 3)

indice <- which.min(abs(sol_aprox$T - 1.4))
print(paste("El valor de W en T = 1.4 es:", sol_aprox$W[indice]))

my_colors=c("y(x)"="green", "w(x)"="gray")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  coord_cartesian(xlim = c(1, 1.4))+
  theme_bw()

ggplotly(graf)

``` 
 
 
## Comparaciones


```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 x - x * y
}

# Solución exacta
y_sol <- function(x){
  2*exp(1/2-x^2/2)+1
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)



``` 
 
# Problema 3

Suppose that we use the Improved Euler's method to approximate the solution to the differential equation
dydx=x−0.5y;y(0)=9.
Let f(x,y)=x−0.5y.

We let x0=0
 and y0=9
 and pick a step size h=0.25.
 The improved Euler method is the the following algorithm. From (xn,yn),
 our approximation to the solution of the differential equation at the n
-th stage, we find the next stage by computing the x
-step xn+1=xn+h,
 and then k1,
 the slope at (xn,yn).
 The predicted new value of the solution is zn+1=yn+h⋅k1.
 Then we find the slope at the predicted new point k2=f(xn+1,zn+1)
 and get the corrected point by averaging slopes
yn+1=yn+h2(k1+k2)
 
```{r}
f <- function(x, y) {
  x-0.5*y
}

y_sol <- function(x) {
 2*x-4+13*exp(-x/2)
}

euler_modificado <- function(f, a, b, N, y0) {
  h <- (b - a) / N
  X <- seq(a, b, by = h)
  Y <- y0
  K1<-numeric()
  K2<-numeric()
  Z<-numeric()
  for (k in 1:N) {
    K1[k]<- f(X[k], Y[k])
    Z[k]=Y[k]+h*K1[k]
    K2[k]=f(X[k+1], Z[k])
    Y[k + 1] <- Y[k] + h / 2 *(K1[k]+ K2[k])
   # Y[k + 1] <- Y[k] + h / 2 * (f(X[k], Y[k])+f(X[k + 1], Y[k] + h * f(X[k], Y[k])))
    

  }
  resultados <- list("X" = X, "Y" = Y, "K1"=K1, "Z"=Z, "K2"=K2)
  return(resultados)
}

sol_aprox<-euler_modificado(f,0, 1,4,9)


graf <- ggplot() +
  geom_function(fun = y_sol, xlim = c(0.1, 1.1), color = "red4", linewidth = .7) +
  geom_line(aes(x = sol_aprox$X, y = sol_aprox$Y), color = "cyan3", linewidth = .7) +
  theme_test()

ggplotly(graf)



```

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 x-0.5*y
}

# Solución exacta
y_sol <- function(x){
  2*x-4+13*exp(-x/2)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```
 
 
 
 
# Problema 4 
Suppose that we use Euler's method to approximate the solution to the differential equation
$ \frac{dy}{dx}=x^5/y; \quad y(0.5)=2$

Let $f(x,y)=x^5/y.$

We let $x0=0.5$
 and $y0=2$
 and pick a step size $h=0.2.$
 Euler's method is the the following algorithm. From xn
 and yn,
 our approximations to the solution of the differential equation at the nth stage, we find the next stage by computing
xn+1=xn+h,yn+1=yn+h⋅f(xn,yn).

```{r}
f <- function(x, y) {
  x^5/y
}

euler_modificado <- function(f, a, b, N, y0) {
  h <- (b - a) / N
  X <- seq(a, b, by = h)
  Y <- numeric(N + 1)
  Y[1] <- y0
  for (k in 1:N) {
    Y[k + 1] <- Y[k] + h * f(X[k], Y[k])
  }
  resultados <- list("X" = X, "Y" = Y)
  return(resultados)
}

sol_aprox <- euler_modificado(f, 0.5, 1.5, 5, 2)


graf <- ggplot() +
  geom_function(fun = y_sol, xlim = c(0.1, 1.1), color = "red4", linewidth = .7) +
  geom_line(aes(x = sol_aprox$X, y = sol_aprox$Y), color = "cyan3", linewidth = .7) +
  theme_test()

ggplotly(graf)
```

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 x^5/y
}

# Solución exacta
y_sol <- function(x){
  ((192*x^6+2301)^(1/2))/24
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```
 
 
# Problema 5{.tabset}

Let y(t)
 be the solution to y˙=7te−y
 satisfying y(0)=2
.

## (a) Use Euler's Method with time step h=0.2to approximate y(0.2),y(0.4),...,y(1.0)
.

```{r}
dy <- function(t,y){
  7*t*exp(-y)
}
y_sol <- function(t){
  log(7*t^2/2+exp(2))
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 1, 5, 2)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=y_sol, xlim=c(0,1))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)

```

## errores

```{r}
# Calcular los errores en las aproximaciones
error_0.2 <- abs(y_sol(0.2) - sol_aprox$W[which(sol_aprox$T == 0.2)])
error_0.6 <- abs(y_sol(0.6) - sol_aprox$W[which(sol_aprox$T == 0.6)])
error_0.6 <- numeric(0)
indice_0.6 <- which.min(abs(sol_aprox$T - 0.6))
if (length(indice_0.6) > 0) {
  error_0.6 <- abs(y_sol(0.6) - sol_aprox$W[indice_0.6])
}

error_1 <- abs(y_sol(1) - sol_aprox$W[which(sol_aprox$T == 1)])



```

## Comparaciones
```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 7*x*exp(-y)
}

# Solución exacta
y_sol <- function(x){
  log(7*x^2/2+exp(2))
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```
 
# Problema 6

 Fill in the missing values in the table given if you know that dy/dt=0.2y
. Assume the rate of growth given by dy/dt
 is approximately constant over each unit time interval and that the initial value of y
 is 8


```{r}
dy <- function(t,y){
  0.2*y
}
y_sol <- function(t){
  5*exp(t/5)
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 4, 4, 8)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=y_sol, xlim=c(0,4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)

```


```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
  0.2*y
}

# Solución exacta
y_sol <- function(x){
  5*exp(x/5)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```
 
# Problema 7 {.tabset}
$ \frac{dB}{dt}=0.04B; \quad B(0)=1000$

## A. Δt=1 and 1 step:  B(1)≈

```{r}
dB <- function(t, B) {
  0.04 * B
}

B_sol <- function(t) {
  1000 * exp(t/25)
}

my_euler <- function(dB, a, b, N, y0) {
  h <- (b - a) / N
  T <- seq(a, b, by = h)
  W <- numeric(N + 1)
  W[1] <- y0
  for (k in 1:N) {
    W[k + 1] <- W[k] + h * dB(T[k], W[k])
  }
  resultados <- list("T" = T, "W" = W)
  return(resultados)
}

a <- 0     
b <- 1     
N <- 1     
y0 <- 1000 


sol_aprox <- my_euler(dB, a, b, N, y0)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=B_sol, xlim=c(0,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```

## B. Δt=0.5 and 2 steps: B(1)≈
 
```{r}
dB <- function(t, B) {
  0.04 * B
}

B_sol <- function(t) {
  1000 * exp(t/25)
}

my_euler <- function(dB, a, b, N, y0) {
  h <- (b - a) / N
  T <- seq(a, b, by = h)
  W <- numeric(N + 1)
  W[1] <- y0
  for (k in 1:N) {
    W[k + 1] <- W[k] + h * dB(T[k], W[k])
  }
  resultados <- list("T" = T, "W" = W)
  return(resultados)
}

a <- 0     
b <- 1     
N <- 2  
y0 <- 1000 


sol_aprox <- my_euler(dB, a, b, N, y0)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=B_sol, xlim=c(0,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```

## C. Δt=0.25 and 4 steps: B(1)≈
 

```{r}
dB <- function(t, B) {
  0.04 * B
}

B_sol <- function(t) {
  1000 * exp(t/25)
}

my_euler <- function(dB, a, b, N, y0) {
  h <- (b - a) / N
  T <- seq(a, b, by = h)
  W <- numeric(N + 1)
  W[1] <- y0
  for (k in 1:N) {
    W[k + 1] <- W[k] + h * dB(T[k], W[k])
  }
  resultados <- list("T" = T, "W" = W)
  return(resultados)
}

a <- 0     
b <- 1     
N <- 4   
y0 <- 1000 


sol_aprox <- my_euler(dB, a, b, N, y0)

my_colors=c("y(t)"="firebrick", "w(t)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=B_sol, xlim=c(0,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```

# Problema 8 {.tabset}

 Consider the solution of the differential equation y′=4y
 passing through y(0)=1.5
.
## A.
Sketch the slope field for this differential equation, and sketch the solution passing through the point (0,1).
```{r}
# Cargar la librería
library(ggplot2)

# Definir la ecuación diferencial
dy <- function(t, y) {
  4*y
}

# Método de Euler para aproximar la solución
euler <- function(dy, t_range, y0, h) {
  t <- seq(t_range[1], t_range[2], by = h)
  y <- numeric(length(t))
  y[1] <- y0
  for (i in 2:length(t)) {
    y[i] <- y[i - 1] + h * dy(t[i - 1], y[i - 1])
  }
  return(data.frame(t = t, y = y))
}

# Parámetros
t_range <- c(0, 1)  # Rango de tiempo
y0 <- 1.5            # Condición inicial
h <- 0.2            # Tamaño de paso

# Aproximar la solución utilizando el método de Euler
sol <- euler(dy, t_range, y0, h)

# Graficar el campo de pendiente
ggplot(data.frame(t = seq(t_range[1], t_range[2], by = 0.5)), aes(t, 1)) +
  geom_segment(aes(yend = 1 + 0.5 * dy(t, 1), xend = t), arrow = arrow(length = unit(0.3, "cm"))) +
  geom_point(data = data.frame(t = 0, y = 1), aes(t, y), color = "red", size = 3) +
  geom_path(data = sol, aes(t, y), color = "blue") +
  xlim(t_range) +
  ylim(c(-1, 2)) +
  labs(x = "t", y = "y(t)", title = "Campo de pendiente y Solución") +
  theme_minimal()

```

## B
Use Euler's method with step size Δx=0.2
 to estimate the solution at x=0.2,0.4,…,1
, using these to fill in the following table. (Be sure not to round your answers at each step!)

```{r}
f <- function(x, y) {
  4*y
}

euler_modificado <- function(f, a, b, N, y0) {
  h <- (b - a) / N
  X <- seq(a, b, by = h)
  Y <- numeric(N + 1)
  Y[1] <- y0
  for (k in 1:N) {
    Y[k + 1] <- Y[k] + h * f(X[k], Y[k])
  }
  resultados <- list("X" = X, "Y" = Y)
  return(resultados)
}

sol_aprox <- euler_modificado(f, 0, 1, 5, 1.5)


graf <- ggplot() +
  geom_function(fun = y_sol, xlim = c(0, 1), color = "red4", linewidth = .7) +
  geom_line(aes(x = sol_aprox$X, y = sol_aprox$Y), color = "cyan3", linewidth = .7) +
  theme_test()

ggplotly(graf)
```

```{r}
dy <- function(x,y){
  4*y
}
y_sol <- function(x){
  3*exp(4*x)/2
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 1.5, 5, 1)

my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(0,1))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```

## C
Plot your estimated solution on your slope field. Compare the solution and the slope field. Is the estimated solution an over or under estimate for the actual solution?

subestimados

## Comparación

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 4*y
}

# Solución exacta
y_sol <- function(x){
  3*exp(4*x)/2
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)


```

# Problema 9 {.tabset}

Consider the differential equation
$ \frac{dy}{dx}=7x; \quad y(0)=5$.

## A 
Use Euler's method with two steps to estimate y
 when x=1

```{r}
dy <- function(x,y){
  7*x
}
y_sol <- function(x){
  7*x^2/2+5
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 1, 2, 5)
Y_aprox_1 <- sol_aprox$W[length(sol_aprox$W)]

# Calcular B_sol(1) (solución exacta)
Y_exact <- y_sol(1)


my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(0,1))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```


## B
Now use four steps:

```{r}
dy <- function(x,y){
  7*x
}
y_sol <- function(x){
  7*x^2/2+5
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 1, 4, 5)
Y_aprox_1 <- sol_aprox$W[length(sol_aprox$W)]

# Calcular B_sol(1) (solución exacta)
Y_exact <- y_sol(1)


my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(0,1))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```


## C
C. What is the magnitude of the error in the two Euler approximations you found?
Magnitude of error in Euler with 2 steps = 

Magnitude of error in Euler with 4 steps =

## D

By what factor should the error in these approximations change (that is, the error with two steps should be what number times the error with four)?

El factor por el cual cambia el error en estas aproximaciones se puede calcular dividiendo el error con dos pasos entre el error con cuatro pasos
factor=(Error euler N=2)/(Error euler N=4)

## Comparación

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
  7*x
}

# Solución exacta
y_sol <- function(x){
  7*x^2/2+5
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)



```
 
# Problema 10 {.tabset}

$y'= -x-y$

## Use Euler's method with Δx=0.1
 to estimate y
 when x=1.4
 for the solution curve satisfying
y(1)=1
 : Euler's approximation gives y(1.4)≈
 
```{r}
dy <- function(x,y){
  -x-y
}
y_sol <- function(x){
  exp(1-x)-x+1
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 1.4, 4, 1)

my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,1.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```
 

## Use Euler's method with Δx=0.1
 to estimate y
 when x=2.4
 for the solution curve satisfying y(1)=0
 : Euler's approximation gives  y(2.4)≈

```{r}
dy <- function(x,y){
  -x-y
}
y_sol <- function(x){
  exp(1-x)-x+1
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 2.4, 14, 0)

my_colors=c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(1,2.4))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="x", y="y(x)", color=" ")+
  theme_bw()

ggplotly(graf)
```

## Comparación

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 -x-y
}

# Solución exacta
y_sol <- function(x){
  exp(1-x)-x+1
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)


```
 
 
 
# Problema 11
Use Euler's method with step size 0.25
 to compute the approximate y -values y1,
 y2, y3, and y4 of the solution of the initial-value problem

$y′=2-5x+4y$   $y(1)=-1.$




```{r}
f <- function(x, y) {
  return(2 - 5*x + 4*y)
}

h <- 0.25
x0 <- 1
y0 <- -1

euler <- function(x, y, h) {
  return(y + h * f(x, y))
}

x1 <- x0 + h
y1 <- euler(x0, y0, h)

x2 <- x1 + h
y2 <- euler(x1, y1, h)

x3 <- x2 + h
y3 <- euler(x2, y2, h)

x4 <- x3 + h
y4 <- euler(x3, y3, h)

print(paste("y1 ≈", y1))
print(paste("y2 ≈", y2))
print(paste("y3 ≈", y3))
print(paste("y4 ≈", y4))
```

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
 return(2 + 5*x + 2*y)
}

# Solución exacta
y_sol <- function(x){
  ((20*x-3)*exp(4)-33*exp(4*x))/16*exp(4)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
``` 
 
# Problema 12
Use Euler's method with step size 0.3
 to estimate y(1.5)
, where y(x)
 is the solution of the initial-value problem
 
$y′=5x+y^2$   $y(0)=1$ 


```{r}
f <- function(x, y) {
  return(-5*x + y^2)
}

h <- 0.3
x_target <- 1.5
x0 <- 0
y0 <- 0

euler <- function(x, y, h) {
  return(y + h * f(x, y))
}

while (x0 < x_target) {
  y0 <- euler(x0, y0, h)
  x0 <- x0 + h
}

```

```{r}
library(ggplot2)
library(plotly)

dy <- function(x, y){
  return(-5*x + y^2)
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)

```
 
```{r}
f <- function(x, y) {
  return(-5*x + y^2)
}

h <- 0.3
x_target <- 1.5
x0 <- 0
y0 <- 1

euler <- function(x, y, h) {
  return(y + h * f(x, y))
}

while (x0 < x_target) {
  y0 <- euler(x0, y0, h)
  x0 <- x0 + h
  print(paste("x:", x0, ", y:", y0))
}

```

 
# Problema 13

Suppose you have just poured a cup of freshly brewed coffee with temperature 90∘C
 in a room where the temperature is 25∘C
.
Newton's Law of Cooling states that the rate of cooling of an object is proportional to the temperature difference between the object and its surroundings. Therefore, the temperature of the coffee, T(t)
, satisfies the differential equation
dTdt=k(T−Troom)
where Troom=25
 is the room temperature, and k
 is some constant.
Suppose it is known that the coffee cools at a rate of 2∘C
 per minute when its temperature is 75∘C
.

 
```{r}
T0 <- 75  
Ts <- 25  
dT_dt <- -2  

k <- dT_dt / (T0 - Ts)
cat("k es:", k, "1/min\n")
```


```{r}
f <- function(T0, Ts, k, h, t) {
  T <- T0
  for (i in 1:(t/h)) {
    T <- T + h * k * (T - Ts)
  }
  return(T)
}

T0 <- 90  
Ts <- 25  
h <- 2    
t <- 10   # Tiempo total en minutos
k <- -0.04


T10 <- f(T0, Ts, k, h, t)

print(paste("T(10) ≈", T10, "°C"))
```

# Problema 14

Solve the initial-value problem $y′+3y=8$, $y(0)=0.$

```{r}
library(ggplot2)

# Definición de la función exacta
y_sol <- function(t){
  return(-(8*exp(-3*t)/3)+8/3)
}

# Definición de la ecuación diferencial
f <- function(t, y){
  return(8-3*y)
}

# Definición de la función para resolver la EDO usando el método de Euler-Heun
euler_heun <- function(f, t0, tf, y0, n) {
  h <- (tf - t0) / n
  t <- seq(t0, tf, by = h)
  y <- numeric(n + 1)
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(t[i], y[i])
    k2 <- f(t[i] + h, y[i] + h * k1)
    y[i + 1] <- y[i] + (h / 2) * (k1 + k2)
  }
  return(data.frame(t = t, y = y))
}

# Obtener la aproximación numérica
sol_aprox <- euler_heun(f, 0, 2, 0, n = 10)

# Crear el gráfico
ggplot() +
  geom_function(aes(color = "y(x)"), fun = y_sol, xlim = c(0, 2)) +
  geom_line(data = sol_aprox, aes(t, y, color = "w(x)")) +
  labs(x = "t", y = "y(t)", color = "") +
  scale_color_manual(values = c("firebrick", "dodgerblue")) +
  theme_bw()

```

# Problema 15

```{r}
# Método de Euler-Heun
euler_heun <- function(f, t0, tf, y0, n) {
  h <- (tf - t0) / n
  t <- seq(t0, tf, by = h)
  y <- numeric(n + 1)
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(t[i], y[i])
    k2 <- f(t[i] + h, y[i] + h * k1)
    y[i + 1] <- y[i] + (h / 2) * (k1 + k2)
  }
  return(data.frame(t = t, y = y))
}


# Definición de la ecuación diferencial
f <- function(t, y) {
  return(0.1 * y * (1 - y / 20000) * (1 - 900 / y))
}

# Valor inicial
y0 <- 1000

# Obtener la aproximación numérica utilizando el método de Euler-Heun
sol_aprox <- euler_heun(f, 0, 60, y0, n = 300)

# Gráfico
library(ggplot2)
ggplot() +
  geom_line(data = sol_aprox, aes(t, y), color = "red") +
  labs(x = "t", y = "y(t)") +
  theme_bw()
```

# Problema 16
 
 
```{r}
f<-function(t,y){
  0.08*y-0.00016*y^2
}
y0<0


sol_aprox<-euler_heun(f,0,200,y0,n=300)
graf<-ggplot()+
  geom_line(aes(sol_aprox$t, sol_aprox$y), color="green")
theme_bw()

ggplotly(graf)

```
# Problema 17
 
```{r}
dy <- function(x,y){
  exp(2*x)-3*y
}
y_sol <- function(x){
      4/5*exp(-3*x)+exp(2*x)/5
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 2, 100, 1)

indice <- which(sol_aprox$T == 1.4)
print(sol_aprox$W[indice])


my_colors=c("y(x)"="orange", "w(x)"="black")

graf<-ggplot()+
  geom_function(aes(color="y(x)"),fun=y_sol, xlim=c(0,2))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(x)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```

```{r}
dy <- function(x, y){
 exp(2*x)-3*y
}

y_sol <- function(x){
  4/5*exp(-3*x)+exp(2*x)/5
}

euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}


rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

x0 <- 0
xn <- 10
y0 <- 1
n <- 100


aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)



sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```

# Problema 18

```{r}
dy <- function(x,y){
  x^(-2)-1/(x+7)*y
}

y_sol <- function(x){
  (x*log(x)-7)/x*(x+7) + 31/((x+7))
}

my_euler <- function(dy, a, b, N, y0){
  h <- (b-a)/N
  T <- numeric(N+1)
  W <- numeric(N+1)
  T[1] <- a
  W[1] <- y0
  for (k in 1:N) {
    W[k+1] <- W[k] + h*dy(T[k], W[k])
    T[k+1] <- T[k] + h
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 1, 2, 100, 3)

indice <- which(sol_aprox$T == 1.4)
print(sol_aprox$W[indice])

library(ggplot2)
library(plotly)

my_colors <- c("y(x)"="firebrick", "w(x)"="dodgerblue")

graf <- ggplot() +
  geom_function(aes(color="y(x)"), fun=y_sol, xlim=c(1,2)) +
  geom_line(aes(sol_aprox$T, sol_aprox$W, color="w(x)")) +
  scale_color_manual(values=my_colors) +
  labs(x="t", y="y(t)", color=" ") +
  theme_bw()

ggplotly(graf)

```


```{r}
dy <- function(x, y){
 x^(-2)-1/(x+7)*y
}

# Solución exacta
y_sol <- function(x){
  (x*log(x)-7)/x*(x+7) + 31/((x+7))
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```


# Problema 19


```{r}
dy <- function(t,y){
  7*exp(t)+7*exp(8*t)+y
}
y_sol <- function(t){
  7*t*exp(t)+exp(8*t)+3*exp(t)
}

my_euler <- function(dy, a,b, N, y0){
  h <- (b-a)/N
  T <- a
  W <- y0
  for (k in 1:N) {
    w_new <- W[k]+ h*dy(T[k], W[k])
    T <- c(T, T[k]+h)
    W <- c(W, w_new)
  }
  resultados <- list("T"=T, "W"=W)
  return(resultados)
}

sol_aprox <- my_euler(dy, 0, 15, 100, 4)

my_colors=c("y(t)"="green", "w(t)"="orange")

graf<-ggplot()+
  geom_function(aes(color="y(t)"),fun=y_sol, xlim=c(0,15))+
  geom_line(aes(sol_aprox$T,sol_aprox$W, color="w(t)"))+
  scale_color_manual(values=my_colors)+
  labs(x="t", y="y(t)", color=" ")+
  theme_bw()

ggplotly(graf)
```


# Problema 20

Consider a series circuit consisting of a resistor of R
 ohms, an inductor of L
 henries, and variable voltage source of V(t)
 volts (time t
 in seconds). The current through the circuit I(t)
 (in amperes) satisfies the differential equation:
dIdt+RLI=1LV(t)
Find the solution to this equation with the initial condition I(0)=0
, assuming that R=70Ω
, L=5
 H, and V(t)
 is constant with V(t)=10
 V
 
```{r}
dy <- function(x, y){
  -70/5*y+2
}

# Solución exacta
y_sol <- function(x){
  1/7-exp(-14*x)/7
}

# Método de Euler-Heun
euler_heun <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h, y[i] + h * k1)
    y[i+1] <- y[i] + h * (k1 + k2) / 2
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta de cuarto orden
rk4 <- function(f, x0, xn, y0, n) {
  h <- (xn - x0)/n
  x <- numeric(n+1)
  y <- numeric(n+1)
  x[1] <- x0
  y[1] <- y0
  for (i in 1:n) {
    k1 <- f(x[i], y[i])
    k2 <- f(x[i] + h/2, y[i] + h/2 * k1)
    k3 <- f(x[i] + h/2, y[i] + h/2 * k2)
    k4 <- f(x[i] + h, y[i] + h * k3)
    y[i+1] <- y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
    x[i+1] <- x[i] + h
  }
  data.frame(x = x, y = y)
}

# Método de Runge-Kutta-Fehlberg de quinto orden
rkf54 <- function(f, x0, xn, y0, tol) {
  # Código para RK-Fehlberg
}

# Parámetros de la simulación
x0 <- 0
xn <- 10
y0 <- 1
n <- 100

# Obtener aproximaciones numéricas
aprox_euler <- euler_heun(dy, x0, xn, y0, n)
aprox_rk4 <- rk4(dy, x0, xn, y0, n)
#aprox_rk54 <- rkf54(dy, x0, xn, y0, tol)

# Gráfico comparativo
sols_1 <- ggplot() +
  geom_line(data = aprox_euler, aes(x = x, y = y, color = "Euler-Heun")) +
  geom_line(data = aprox_rk4, aes(x = x, y = y, color = "Runge-Kutta 4")) +
  #geom_line(data = aprox_rk54, aes(x = x, y = y, color = "Runge-Kutta Fehlberg 5/4")) +
  stat_function(fun = y_sol, aes(color = "Solución Exacta")) +
  labs(x = "x", y = "y", color = "Método") +
  theme_bw()

ggplotly(sols_1)
```

 
 
 
 






